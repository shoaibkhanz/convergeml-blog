{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-convergeml","title":"Welcome to ConvergeML","text":"<p>Thank you for visiting ConvergeML, a space dedicated to exploring and demystifying the complex world of machine learning. Here, I document my learnings and insights as I work through the full lifecycle of ML models, from defining use cases and understanding deployment considerations to testing, refining, interpreting, and monitoring models.</p> <p>In machine learning, one principle remains clear: \"All models are wrong, but some are useful.\" This quote from statistician George Box reminds us that models, while inherently simplified representations of reality, have the potential to unlock valuable insights and support impactful decisions. At ConvergeML, I approach model building with this in mind\u2014starting from the use case, carefully considering how models fit into broader systems, and making deliberate choices about which assumptions to make.</p> <p>Once data is in hand, the real value often lies in feature engineering\u2014transforming, selecting, and crafting features that bring out the meaningful patterns within the data. This process goes beyond the idea that \"data is the new oil\" to a more refined focus on shaping the data in ways that maximize a model's interpretability and predictive power. Here, I aim to highlight the importance of this step, demonstrating techniques to improve both model performance and clarity.</p> <p>Another key aspect of ConvergeML is building foundational understanding by implementing things from scratch. By constructing algorithms and models from the ground up, I hope to achieve a deeper grasp of each component\u2019s function and behavior. Much like a mathematician testing assumptions, I believe in poking models and testing their behavior. This hands-on approach not only strengthens my understanding but also reveals insights into how models can be refined to handle a range of scenarios effectively.</p> <p>I hope the content here serves as a valuable resource for anyone interested in learning, experimenting, and advancing their understanding of machine learning. ConvergeML is built for those who, like me, believe that machine learning is not just about building models but about developing a solid foundation in the principles that drive them.</p> <p>Welcome to ConvergeML\u2014an evolving journey of discovery in AI.</p>"},{"location":"posts/2020/2020-05-22-Time-Series-Forecasting-using-Prophet-part1/","title":"Time-Series Forecasting using Prophet- part1","text":"<p>Prophet is a time-series forecasting library by facebook and it's available in Python and in R. It is simple to use and requires very little classical time-series experience, for e.g. ARIMA, SARIMA etc. Thus, you can start building models quickly, get good results and become effective in no time. Considering this, prophet has become a popular library for time-series applications.</p> <p>A model in prophet is defined by the following equation.  This form is called general additive model, since we adding results from each of the components to get our prediction. $$ \\widehat{Y}_t = g_t + s_t + h_t + x_t + \\epsilon $$</p> <p>$ \\hat Y_t $ is the prediction.</p> <p>$ g_t $ stands for the growth model, i.e., trend (logistic/linear).</p> <p>$ s_t $ models seasonality using Fourier series.</p> <p>$ h_t $ models holiday effects.</p> <p>$ x_t $ represents any extra regressors.</p> <p>$ \\epsilon $ represents normally distributed errors.</p>"},{"location":"posts/2020/2020-05-22-Time-Series-Forecasting-using-Prophet-part1/#what-is-this-post-about","title":"What is this post about ?","text":"<p>In this first post on prophet ,my objective is simply to get you started with  forecasting. I aim to cover the very basic to get you off the ground. In this series of posts, the aim is to cover all the features of prophet in parts. We will explore under-the-hood mathematics that defines prophet and tinker with how it's applied in code. For now, I will make sure that after reading this you know enough to get your first time-series model up and running. </p> <p> All the code required to run the model is available on GitHub here</p>"},{"location":"posts/2020/2020-05-22-Time-Series-Forecasting-using-Prophet-part1/#dataset","title":"Dataset","text":"<p>Time-series data is where the values are recorded sequentially with respect to time, for e.g. temperature data or health tracker data etc. For this post, we will model maximum temperature data for Sydney, Australia between the years 2013-2017 and we want to forecast it another year. This data has a strong seasonal pattern with a weak trend (Fig1). If at this point you are wondering what do we mean by seasonality and trend then you must read time-series patterns by rob hyndman before reading any further.</p>"},{"location":"posts/2020/2020-05-22-Time-Series-Forecasting-using-Prophet-part1/#setting-up-to-explore-and-forecast","title":"Setting up to explore and forecast","text":"<p>We want to set up our environment with libraries that we would need for this forecasting exercise. So, we install the necessary packages below.</p> <pre><code># Importing the libraries\nimport pandas as pd #for data manipulation\nimport matplotlib.pyplot as plt #for plotting\nfrom fbprophet import Prophet #for forecasting\n</code></pre> <p>We then read our data which is stored as a <code>csv</code>. This data contains around 24 variables but we are interested in 2 variables MaxTemp since its the target and the Date variable as it's the primary time sequence. Prophet requires the date variable to be set as a datetime object and so we must convert it so. However, the interesting thing here is that we must name our date variable as ds and the target variable as y, this is how prophet expects  them to be.</p> <pre><code># reading a csv\ndf = pd.read_csv('../datasets/ausraindata.csv')\n# converting the string to datetime object\ndf['ds'] = pd.to_datetime(df['Date'])\n# creating a new variable y \n# i.e. target variable, same as MaxTemp\n# If you wanted to, you could rename it as well.\ndf['y'] = df['MaxTemp']\n</code></pre> <p>The data contains temperature values for many locations across Australia, We are going to filter, select on Sydney, and extract data from 2013 onwards.</p> <pre><code># filtering the data by 2 conditions\ndf = df.loc[(df['Location']=='Sydney') &amp; \n(df['ds'].dt.year &gt;=2013),:]\n# selecting the required variables\ndf = df.loc[:,['ds','y']]\n</code></pre> <p>As we feel the need to plot the time-series to understand how the maximum temperature (measured in Celsius degrees) has been across these years. We observe that it has peaks and valleys which we should expect as the temperature drops during winters and increases back up during summers. Thus, it's seasonal and we should expect the model to detect this pattern.</p> <pre><code>#plotting the time-series\nfig, ax = plt.subplots(figsize = (15,4))\nax.plot(df['ds'], df['y'])\nax.set_title('Max Temperature in Sydney from 2013-2017')\nplt.show()\n</code></pre> <p></p>"},{"location":"posts/2020/2020-05-22-Time-Series-Forecasting-using-Prophet-part1/#fitting-a-prophet-model","title":"Fitting a Prophet model","text":"<p>We have the data ready containing only 2 variables i.e. ds and y and this is sufficient to build our very basic prophet model. The first step is to instantiate the model by calling Prophet class and define seasonality. {% sidenote '1' 'although we are just defining seasonality there are many default options that get chosen for us. e.g. by default seasonality mode is always <code>additive</code> but we could change it to multiplicative if required.'%}</p> <p>After creating the <code>m1</code> object we fit it to the data. Once, we have completed this step successfully, we must create a forecasting dataframe with future dates using the <code>make_future_dataframe</code> method. We use <code>periods</code> to define the length of the forecasting dates and then simply predict. Now the <code>forecast1</code> dataframe contains train and test data along with the forecast values called <code>yhat</code>.</p> <pre><code># training a prophet model \nm1 =  Prophet(daily_seasonality=False, \n              weekly_seasonality=True, \n              yearly_seasonality=True)\nm1.fit(df)\nfuture1 = m1.make_future_dataframe(periods=365)\nforecast1 = m1.predict(future1)\nforecast1.tail()\n</code></pre> <p>forecast1 dataframe multiple variables but the key variables we focus for now are ds,trend,weekly,yearly and yhat</p> <p>$ \\hat Y = $ trend + weekly + yearly </p> ds trend weekly yearly yhat 2018-06-21 24.032494 0.156514 -5.219729 18.969280 2018-06-22 24.032998 0.007727 -5.289494 18.751232 2018-06-23 24.033502 -0.059232 -5.356488 18.617783 2018-06-24 24.034006 -0.119039 -5.420102 18.494865 2018-06-25 24.034510 -0.024526 -5.479695 18.530289"},{"location":"posts/2020/2020-05-22-Time-Series-Forecasting-using-Prophet-part1/#predictions-trend-and-seasonality","title":"Predictions, Trend and Seasonality","text":"<p>Prophet provides some useful functions to plot data. there are 2 backends avaiable <code>plotly</code> and <code>matplotlib</code>. We use matplotlib to plot the predictions. The function plots 95% confidence intervals as well. The predicitons are plotted as a line and the actuals as points. You could easily plot it yourself if you plotted the <code>yhat</code> from the <code>forecast1</code> dataframe.</p> <p><pre><code># plots the predictions\nm1.plot(forecast1)\n</code></pre> </p> <p>If we now wanted to plot trend and seasonality from the model we could easily do so by calling the <code>plot_components</code> method. We notice that Tuesdays and Thursdays are hotter than others and the values are relatively extremely small, this may suggest that this may not be significant. Interestingly, due to the location of australia, the weather is very different compared to other parts of the world. We observe in the yearly seasonality plot that July is the coldest while December is the hottest.  {% sidenote '2' 'This is also apparent if we compare yearly seasonality with Fig1' %}.</p> <pre><code># plots the trend and seasonality\nm1.plot_components(forecast1)\n</code></pre> <p></p>"},{"location":"posts/2020/2020-05-22-Time-Series-Forecasting-using-Prophet-part1/#key-takeaways","title":"Key Takeaways","text":"<p>I hope after reading this post you are confident to run your basic prophet model and make forecasts about them. Now there is a lot that I haven't covered here e.g. </p> <p>1.) What are changepoints? </p> <p>2.) What do we mean by logistic and linear trend?</p> <p>3.) How is seasonality calculated (Fourier series)? </p> <p>4.) Time-series cross-validation and performance metrics etc.</p> <p>5.) How do you boost model performance? </p> <p>Future posts in this series will help answer all these questions. My goal for this one was to get you started without making you feel overwhelmed with the features. Once again, all the code is stored here, there is also a <code>utils.py</code> file in the project that gives the appearance of the charts.</p> <p>Let me know in the comments, if you found this post helpful or you find yourself full of doubts.</p>"},{"location":"posts/2020/2020-05-31-Time-Series-Forecasting-using-Prophet-part2/","title":"Time-Series Forecasting using Prophet- part2","text":"<p>In the last post, we learned that we can build a simple Prophet model by combining trend and seasonality to forecast the future. We saw, that in the model equation not only can we add those factors but we can also include holidays effects and extra regressors, which makes it extremely powerful. </p> <p>Let's just remind ourselves how this looks like. $$  \\widehat{Y}_t = g_t + s_t + h_t + x_t + \\epsilon  $$  </p> <p>$ \\hat Y_t $ is the prediction.</p> <p>$ g_t $ stands for the growth model, i.e., trend (logistic/linear).</p> <p>$ s_t $ models seasonality using Fourier series.</p> <p>$ h_t $ models holiday effects.</p> <p>$ x_t $ represents any extra regressors.</p> <p>$ \\epsilon $ represents normally distributed errors.</p> <p>In this post, we will dive deep to understand trend, uncover the 2 options available and how they model trend differently. We will also learn about changepoints that allow the trend to change at specific points. </p>"},{"location":"posts/2020/2020-05-31-Time-Series-Forecasting-using-Prophet-part2/#what-is-trend","title":"What is trend ?","text":"<p>When we say, we want to extract trend from the data, we essentially are looking to understand the overall trajectory of our time series. We want to know if the series has an increasing or decreasing trend. </p> <p>Here are 2 examples of trend. </p> <p></p> <p></p> <p>Trends are not always increasing or decreasing but they may also consist of changes at points in time. One of the ways trend can be calculated is by computing  rolling mean. Below we have a weekly rolling mean and it's able to follow the path of our series.</p> <p></p> <p>There are 2 ways that trend is calculated in Prophet via  Linear and  Logistic growth models. However, logistic growth has more bells and whistles, which makes it more interesting. </p>"},{"location":"posts/2020/2020-05-31-Time-Series-Forecasting-using-Prophet-part2/#logistic-growth","title":"Logistic growth","text":"<p>Logistic growth captures non-linear relationship i.e.  trend can be curvy and it is also possible to decide saturation values at some defined points. </p> <p>You might ask what do we mean by  saturation ? </p> <p>Well, Imagine our company is providing internet services and we have been given a task to  calculate trend. </p> <p>What a dull exercise but let's just stick with it for now!</p> <p>The sales is increasing but we can never out grow the population of the area thus our trend can never increase beyond this threshold, its simply a constraint for our business. This bound is called the  carrying capacity \\(C\\). </p> <p>Population can grow and shrink with time as well, and thus with logistic growth model we can define the bounds of this growth. We could define it as a  single value that remains constant for the entire timeseries or we may give different values for different points in time i.e.  a vector containing different values.</p> <p>Let's now strip away the complexity and look at the basic form of logistic trend. $$ g_t = \\frac{C}{1+exp(-k(t-m))} $$</p> <p>\\(C\\) is the carrying capacity i.e. bounds.</p> <p>\\(k\\) is the growth rate.</p> <p>\\(m\\) is an offset parameter.</p> <p>Here is how, we define it in code to get an intuition.</p> <p><pre><code>#defining a function\ndef base_trend(c,k,t,m):\n  trend = c/(1+np.exp(-k*(t-m)))\n  return trend\n\n#setting values\nc = 1000\nk = 1\nt = np.linspace(1,50,50)\nm = 20\n</code></pre> In the plot, you will observe that it's saturating at \\(c=1000\\), with an offset at \\(m=20\\) (\\(m\\) allows the graph to move sideways), \\(k\\) is the initial growth and it determines the curvature of the line. </p> <p></p> <p>Let's just plot another graph like the above but with different values and try to get an intuiton of what's really happening here. </p> <p>We have changed the carrying capacity \\(C\\) from 1000 to 100,  \\(k\\) is also changed to 5, which has resulted in a sudden increase in the function, its not as  smooth as before and finally  \\(m\\) has caused the graph to shift  10 units to the left.</p> <pre><code>#setting values\nc = 100\nk = 5\nt = np.linspace(1,50,50)\nm = 10\n</code></pre> <p></p>"},{"location":"posts/2020/2020-05-31-Time-Series-Forecasting-using-Prophet-part2/#changepoints","title":"Changepoints","text":"<p>In the growth function we can define dates where the trend is  allowed to change, those dates are considered as   changepoints. Before we look at the mathematical details, let's just take a look at logistic growth model and plot changepoints. </p> <p>I have simulated some data and we can see the plot below, we notice it has an increasing trend. </p> <p></p> <p>We will model this and focus on the fit and trend plot while setting seasonality to <code>False</code>, I will cover seasonality in detail in part 3. </p> <p>In this Prophet model we have set <code>growth= 'logistic'</code>, but by default it's always <code>linear</code>. The logistic model needs <code>cap</code> and <code>floor</code> values which define upper and lower bounds respectively. </p> <p><pre><code>#training a prophet model by specifying trend \n#i.e. growth function\n\nm1 =  Prophet(growth = 'logistic',\n              daily_seasonality=False, \n              weekly_seasonality=False, \n              yearly_seasonality=False)\n\n#defining bounds in the training data\ndf['cap'] = 50\ndf['floor'] = 1\nm1.fit(df)\nfuture1 = m1.make_future_dataframe(periods=365)\n\n#defining bounds in the testing  data\nfuture1['cap'] = 50\nfuture1['floor'] = 1\n\nforecast1 = m1.predict(future1)\n\n# plotting predictions\nfig, ax = m1.plot(forecast1)\n\n# plotting trend \nfig = m1.plot_components(forecast1)\n</code></pre> Here is the fit plot with the predictions, the black dotted lines are the bounds we had defined for trend. Please know that these bounds are applied to the trend and not to the final predictions. However, they will have their affect on the predictions because trend is part of it, $$\\hat Y_t  = g_t + s_t + h_t + x_t + \\epsilon $$.  </p> <p></p> <p>In this trend plot you can see how  cap at 50 is restricting the trend, If I change the  cap to 40 you will see that trend behaves as if it is constrained not to go beyond 40. That's the effect cap and floor have on trend in the logistic growth model (fig 7-9).</p> <p></p> <p></p> <p></p> <p>Prophet identifies 25 changepoints automatically but by default it only does so for the first 80% of the data. As the user, you have the control to define your own changepoints and also be able control the regularisation (using changepoint_prior_scale) applied to them.</p> <p>Thus, due to regularisation, even when 25 changepoints are considered many changepoint coefficient values is set to near 0. There are fewer than 25 dotted red lines on the plot that's because only changepoints &gt;0.01 are plotted. </p> <p></p> <p>In the below barplot some of the cofficients arent visible on the scale as they are extremely small. We can confirm this if we run --&gt; <code>m1.params['delta]</code></p> <pre><code>array([[ 1.54775876e-08, -4.61800548e-08, -1.00310960e-02,\n        -1.18373641e-01, -7.67190921e-01, -1.06926880e+00,\n        -1.06480754e+00, -8.54049563e-01, -5.53141018e-01,\n        -2.51599717e-01, -5.78373085e-03, -2.55210307e-02,\n        -8.98876919e-07, -1.09167994e-07,  1.41241899e-07,\n        -4.73692876e-08,  1.44643672e-07,  1.10418832e-06,\n         1.68632687e-02,  2.49719169e-03,  1.01259564e-03,\n         4.11508165e-01,  9.30539618e-01,  1.37156022e+00,\n         1.61753520e+00]])\n</code></pre> <p></p> <p>When we consider the logistic growth function with the changepoints, the base formula can then be extended.</p> <p>We go from here: $$ g(t) = \\frac{C}{1 + \\exp(-k(t - m))} $$</p> <p>to: $$ g(t) = \\frac{C(t)}{1 + \\exp(-(k + a(t)^T \\delta)(t - (m + a(t)^T \\gamma)))} $$ It's easy to spot the differences between the 2. The final form consists of 2 main terms in the denominator, the right most term i.e. \\((t - (m + a(t)^T \\gamma))\\) is defined to make function continous, it's the adjustment for the offset. However, it's the previous term which is important especially \\(k + a(t)^T \\delta\\). </p> <p>The \\(a(t)\\) is the place where we define the changepoints and the \\(\\delta\\) are the coefficient values that we extracted using <code>params</code>. To conclude our discussion on changepoints, let's just consider an example of how changepoints really work for a simple case.</p> <p>Let's consider time t as a sequence 1 to 5 and consider we have 2 changepoints, one at t=2 and the other at t=4. </p> <p>We then create \\(\\(a(t)\\)\\) as a vector to define these changepoints. Since we have 2 changepoints we have columns for the vector \\(a(t)\\).</p> <p>We then say that the first changepoint occurs at t=2 and we set that to 1 till the end of the series. Similarly we set the second changepoint to 1 at t=4 and in this way we create a vector that defines our 2 changepoints.  <pre><code> a(1)  =  [0,0] \n a(2)  =  [1,0] \n a(3)  =  [1,0] \n a(4)  =  [1,1] \n a(5)  =  [1,1] \n</code></pre> \\(\\delta\\) is a vector that is the amount the slope changes at each of the changepoints. So <code>delta=[5, 10]</code> means that at the first changepoint the slope increases by 5, and at the second it increases by 10. k is the initial slope, before any changepoints. </p> <p>If we set k=2 and then consider calculating \\(k + a(t)^T \\delta\\), use the matrix and values from above. We then have the following</p> <p><pre><code>t=1: slope is 2 + 0 * 5 + 0 * 10 = 2  # The initial slope\nt=2: slope is 2 + 1 * 5 + 0 * 10 = 7  # At the first changepoint, slope increased by 5\nt=3: slope is 2 + 1 * 5 + 0 * 10 = 7 \nt=4: slope is 2 + 1 * 5 + 1 * 10 = 17  # At the second changepoint, slope increased by 10 more\nt=5: slope is 2 + 1 * 5 + 1 * 10 = 17\n</code></pre> This is how we can calculate logistic trend with changepoints. Linear growth is simpler than this and we discuss it next. </p>"},{"location":"posts/2020/2020-05-31-Time-Series-Forecasting-using-Prophet-part2/#linear-growth","title":"Linear growth","text":"<p>Now that we have understood logistic trend, linear trend becomes fairly simple. The formula for linear growth  should look very similar to logisitc growth but linear trend is linear (see the graph below) and doesnt allow for any trend bounds i.e. carrying capacity. It is defined as below. $$ g(t) = (k + a(t)^T \\delta)t + (m + a(t)^T\\gamma) $$</p> <p>We can run a simple linear growth model as below, the <code>changepoint_prior_scale</code> is a parameter you may use control regularisation, I would encourage you to play with it with your own datasets. </p> <p>Essentially, increasing it will make you trend more flexible and reducing it would decrease the flexibility; by default it is set to <code>0.05</code>. However, this should be used with caution since more flexibility would mean overfitting the training data and thus poor generalisation.</p> <pre><code>m3 =  Prophet(growth = 'linear',daily_seasonality=False, \n              weekly_seasonality=False, \n              yearly_seasonality=False,changepoint_prior_scale=1.05)\nm3.fit(df)\nfuture3 = m3.make_future_dataframe(periods=365)\nforecast3 = m3.predict(future3)\n</code></pre> <p></p> <p></p>"},{"location":"posts/2020/2020-05-31-Time-Series-Forecasting-using-Prophet-part2/#key-takeaways","title":"Key takeaways","text":"<p>In this post, we have learned not only, how to run trend models in Prophet but  how to think about them. We looked at how prophet considers changepoints and regularisation when calculating trend. We  examined various graphs and equations. We also calculated trend in an example setting to see  \"how it works under the hood\".</p> <p>In this effort to introduce time series using prophet, I have started to maintain a repository at GitHub, by no means it's complete. However here is the link to the notebooks. </p> <p>I hope you found this useful and as always,  Happy Forecasting !</p> <p>References: https://github.com/facebook/prophet/issues/1289 https://facebook.github.io/prophet/ https://peerj.com/preprints/3190/</p>"}]}